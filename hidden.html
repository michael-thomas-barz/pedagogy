<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Animation preview for e-mail list</title>
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:           #282828;
    --surface:      #3c3836;
    --border:       #504945;
    --accent:       #d79921;
    --accent2:      #83a598;
    --accent3:      #fb4934;
    --text:         #ebdbb2;
    --text-dim:     #928374;
    --series-color: #b8bb26;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'EB Garamond', serif;
    font-size: 17px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1.5rem 1rem 3rem;
  }

  h1 {
    font-size: 2rem;
    font-weight: 400;
    letter-spacing: 0.02em;
    color: var(--accent);
    margin-bottom: 0.3rem;
    text-align: center;
  }

  .subtitle {
    color: var(--text-dim);
    font-style: italic;
    margin-bottom: 1.5rem;
    text-align: center;
    font-size: 0.95rem;
  }

  /* ── Desktop: info panel left, canvases right ── */
  .main-layout {
    display: flex;
    gap: 2rem;
    align-items: flex-start;
    width: 100%;
    max-width: 1300px;
  }

  .info-panel {
    flex: 0 0 260px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .canvases-col {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
    min-width: 0;
  }

  /* On desktop the two canvases sit side by side */
  .canvases-row {
    display: flex;
    gap: 1.2rem;
    align-items: flex-start;
  }

  .canvas-block {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
  }

  .canvas-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
  }

  /* Canvas fills its flex cell, never overflows */
  canvas {
    width: 100%;
    aspect-ratio: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    display: block;
    touch-action: none;
  }
  #canvas { cursor: crosshair; }

  .canvas-hint {
    font-size: 0.78rem;
    font-style: italic;
    color: var(--text-dim);
    text-align: center;
  }

  /* ── Info cards ── */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 1rem 1.2rem;
  }

  .card-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.62rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 0.5rem;
  }

  .center-display { font-size: 1.2rem; color: var(--accent2); }
  .sqrt-display   { font-size: 1rem;   margin-top: 0.3rem; color: var(--accent); }

  .series-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--series-color);
    line-height: 1.8;
    white-space: pre;
    overflow-x: auto;
  }
  .series-display .coeff { color: var(--accent); }
  .series-display .var   { color: var(--accent2); }

  .monodromy-alert {
    background: #3c2020;
    border: 1px solid var(--accent3);
    border-radius: 4px;
    padding: 0.9rem 1.1rem;
    color: var(--accent3);
    font-size: 0.88rem;
    display: none;
  }
  .monodromy-alert.show { display: block; }

  .reset-btn {
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    border-radius: 2px;
    letter-spacing: 0.1em;
    transition: background 0.2s, color 0.2s;
    align-self: flex-start;
    /* larger touch target */
    min-height: 44px;
  }
  .reset-btn:hover { background: var(--accent); color: var(--bg); }

  /* ── Mobile: stack everything vertically ── */
  @media (max-width: 800px) {
    body { padding: 1rem 0.75rem 2.5rem; font-size: 15px; }

    h1   { font-size: 1.5rem; }

    .main-layout {
      flex-direction: column;
      align-items: stretch;
      gap: 1.2rem;
    }

    .info-panel { flex: none; }

    /* On mobile, canvases stack vertically and each fills screen width */
    .canvases-row {
      flex-direction: column;
      gap: 1.2rem;
    }

    .canvas-block { width: 100%; }

    .series-display { font-size: 0.65rem; }
  }
</style>
</head>
<body>

<h1>Monodromy of √z</h1>
<p class="subtitle">Analytic continuation of the square root around the branch point z = 0</p>

<div class="main-layout">
  <div class="info-panel">
    <div class="card">
      <div class="card-label">Current Center</div>
      <div class="center-display" id="center-display">z₀ = 1</div>
      <div class="sqrt-display"   id="sqrt-display">√(z₀) = 1</div>
    </div>

    <div class="card">
      <div class="card-label">Power Series (this branch)</div>
      <div class="series-display" id="series-display"></div>
    </div>

    <div class="monodromy-alert" id="monodromy-alert">
      ⚠ <strong>Monodromy!</strong> You've returned to a disk containing z = 1, but the branch has flipped: √(1) = −1 on this sheet. Going around z = 0 exchanged the two branches of √z.
    </div>

    <button class="reset-btn" onclick="doReset()">↺ Reset</button>
  </div>

  <div class="canvases-col">
    <div class="canvases-row">
      <div class="canvas-block">
        <div class="canvas-title">z — plane (input)</div>
        <canvas id="canvas" width="430" height="430"></canvas>
        <p class="canvas-hint">Tap inside the current disk to continue √z to a new center.</p>
      </div>
      <div class="canvas-block">
        <div class="canvas-title">√z — plane (output)</div>
        <canvas id="canvas2" width="430" height="430"></canvas>
        <p class="canvas-hint">Each point here is the square root of the matching point on the left.</p>
      </div>
    </div>
  </div>
</div>

<script>
// ── Complex arithmetic ────────────────────────────────────────────────────
function cadd(a,b){return {r:a.r+b.r,i:a.i+b.i};}
function csub(a,b){return {r:a.r-b.r,i:a.i-b.i};}
function cmul(a,b){return {r:a.r*b.r-a.i*b.i,i:a.r*b.i+a.i*b.r};}
function cdiv(a,b){
  var d=b.r*b.r+b.i*b.i;
  return {r:(a.r*b.r+a.i*b.i)/d,i:(a.i*b.r-a.r*b.i)/d};
}
function cabs(a){return Math.sqrt(a.r*a.r+a.i*a.i);}
function cpow(a,n){
  var res={r:1,i:0};
  for(var k=0;k<Math.abs(n);k++) res=cmul(res,a);
  if(n<0) res=cdiv({r:1,i:0},res);
  return res;
}

// ── Formatting ────────────────────────────────────────────────────────────
function fmtC(z,digits){
  if(digits===undefined) digits=2;
  var rv=+z.r.toFixed(digits), iv=+z.i.toFixed(digits);
  if(Math.abs(iv)<0.005) return String(rv);
  if(Math.abs(rv)<0.005) return iv+'i';
  var sign=iv<0?'\u2212':'+';
  return rv+' '+sign+' '+Math.abs(iv)+'i';
}
function fmtCoeff(c){
  var rv=+c.r.toFixed(2), iv=+c.i.toFixed(2);
  if(Math.abs(iv)<0.005) return String(rv);
  if(Math.abs(rv)<0.005) return iv+'i';
  var sign=iv<0?'\u2212':'+';
  return '('+rv+' '+sign+' '+Math.abs(iv)+'i)';
}

// ── Rainbow colors ────────────────────────────────────────────────────────
function stepColor(idx,total){
  var hue=(200+(total<=1?0:idx*300/(total-1)))%360;
  return 'hsl('+hue+',85%,65%)';
}
function stepColorA(idx,total,alpha){
  var hue=(200+(total<=1?0:idx*300/(total-1)))%360;
  return 'hsla('+hue+',85%,65%,'+alpha+')';
}

// ── Power series ──────────────────────────────────────────────────────────
function binomCoeff(n){
  var num=1;
  for(var k=0;k<n;k++) num*=(0.5-k);
  var den=1;
  for(var k=1;k<=n;k++) den*=k;
  return num/den;
}
function seriesCoeffs(z0,sqrtZ0,terms){
  if(terms===undefined) terms=5;
  var coeffs=[];
  for(var n=0;n<terms;n++){
    var bc=binomCoeff(n);
    var z0n=cpow(z0,n);
    coeffs.push(cmul({r:bc,i:0},cdiv(sqrtZ0,z0n)));
  }
  return coeffs;
}
function evalSeries(z0,coeffs,z){
  var dz=csub(z,z0);
  var val={r:0,i:0},dzn={r:1,i:0};
  for(var n=0;n<coeffs.length;n++){
    val=cadd(val,cmul(coeffs[n],dzn));
    dzn=cmul(dzn,dz);
  }
  return val;
}
function radiusOfConvergence(z0){return cabs(z0);}

// ── Build series HTML ─────────────────────────────────────────────────────
function buildSeriesHTML(z0,coeffs,R){
  var terms=[];
  for(var n=0;n<coeffs.length;n++){
    var cs=fmtCoeff(coeffs[n]);
    if(n===0){
      terms.push('<span class="coeff">'+cs+'</span>');
    } else if(n===1){
      terms.push('<span class="coeff">'+cs+'</span>'
        +'<span class="var">\u00b7(z\u2212'+fmtC(z0,2)+')</span>');
    } else {
      terms.push('<span class="coeff">'+cs+'</span>'
        +'<span class="var">\u00b7(z\u2212'+fmtC(z0,2)+')^'+n+'</span>');
    }
  }
  return terms.join('\n+ ')+'\n+ \u2026'
    +'\n\nRadius of convergence:\nR = |z\u2080| = '+R.toFixed(2);
}

// ── State ─────────────────────────────────────────────────────────────────
var state={
  center:{r:1,i:0},
  sqrtVal:{r:1,i:0},
  history:[],
  stepCount:0
};

function doReset(){
  state.center={r:1,i:0};
  state.sqrtVal={r:1,i:0};
  state.history=[{center:{r:1,i:0},sqrt:{r:1,i:0}}];
  state.stepCount=0;
  document.getElementById('monodromy-alert').classList.remove('show');
  updateUI();
  drawBoth();
}

function updateUI(){
  var z0=state.center, sq=state.sqrtVal;
  document.getElementById('center-display').textContent='z\u2080 = '+fmtC(z0);
  document.getElementById('sqrt-display').textContent='\u221a(z\u2080) = '+fmtC(sq);
  var coeffs=seriesCoeffs(z0,sq,4);
  var R=radiusOfConvergence(z0);
  document.getElementById('series-display').innerHTML=buildSeriesHTML(z0,coeffs,R);
}

// ── Canvas ────────────────────────────────────────────────────────────────
// The canvas element has width/height=430 (its internal resolution).
// CSS makes it fluid (width:100%). We always work in internal 430-unit coords
// and convert mouse/touch events using getBoundingClientRect().
var CSIZE=430;
var WORLD=2.5;
var WORLD2=2.0;

var canvas  = document.getElementById('canvas');
var canvas2 = document.getElementById('canvas2');
var ctx     = canvas.getContext('2d');
var ctx2    = canvas2.getContext('2d');

// Convert world → canvas internal coords
function toC(wx,wy){
  return [(wx/WORLD+1)*CSIZE/2,(1-wy/WORLD)*CSIZE/2];
}
function toC2(wx,wy){
  return [(wx/WORLD2+1)*CSIZE/2,(1-wy/WORLD2)*CSIZE/2];
}
// Convert a CSS-pixel point (from mouse/touch event) → internal canvas coords
function cssToInternal(canvas, cssX, cssY){
  var rect=canvas.getBoundingClientRect();
  var scaleX=CSIZE/rect.width;
  var scaleY=CSIZE/rect.height;
  return [(cssX-rect.left)*scaleX,(cssY-rect.top)*scaleY];
}
// Convert internal canvas coords → world coords
function internalToWorld(ix,iy){
  return [ix/CSIZE*2*WORLD-WORLD, -(iy/CSIZE*2*WORLD-WORLD)];
}

// ── Drawing helpers ───────────────────────────────────────────────────────
function drawGrid(c,world){
  c.strokeStyle='#504945'; c.lineWidth=1;
  var lim=Math.ceil(world);
  for(var v=-lim;v<=lim;v++){
    var x=(v/world+1)*CSIZE/2;
    c.beginPath(); c.moveTo(x,0); c.lineTo(x,CSIZE); c.stroke();
    var y=(1-v/world)*CSIZE/2;
    c.beginPath(); c.moveTo(0,y); c.lineTo(CSIZE,y); c.stroke();
  }
}
function drawAxes(c,world){
  var ox=CSIZE/2, oy=CSIZE/2;
  c.strokeStyle='#665c54'; c.lineWidth=1.5;
  c.beginPath(); c.moveTo(ox,0); c.lineTo(ox,CSIZE); c.stroke();
  c.beginPath(); c.moveTo(0,oy); c.lineTo(CSIZE,oy); c.stroke();
  return [ox,oy];
}
function drawAxisLabels(c,world,ox,oy){
  c.fillStyle='#928374'; c.font='11px JetBrains Mono';
  var lim=Math.floor(world);
  for(var v=-lim;v<=lim;v++){
    if(v===0) continue;
    var x=(v/world+1)*CSIZE/2;
    c.fillText(String(v),x-4,oy+15);
    var y=(1-v/world)*CSIZE/2;
    c.fillText(v+'i',ox+4,y+4);
  }
}

// ── Draw z-plane ──────────────────────────────────────────────────────────
function drawZPlane(){
  ctx.clearRect(0,0,CSIZE,CSIZE);
  drawGrid(ctx,WORLD);
  var axes=drawAxes(ctx,WORLD);
  var ox=axes[0],oy=axes[1];

  var total=state.history.length;

  // Disks
  for(var idx=0;idx<total;idx++){
    var h=state.history[idx];
    var R=radiusOfConvergence(h.center);
    var cp=toC(h.center.r,h.center.i);
    var rx=R/WORLD*CSIZE/2;
    var isLast=idx===total-1;
    ctx.beginPath(); ctx.arc(cp[0],cp[1],rx,0,2*Math.PI);
    ctx.strokeStyle=isLast?stepColor(idx,total-1):stepColorA(idx,total-1,0.35);
    ctx.lineWidth=isLast?2:1;
    ctx.stroke();
    ctx.fillStyle=isLast?stepColorA(idx,total-1,0.08):stepColorA(idx,total-1,0.03);
    ctx.fill();
  }

  // Trail
  if(total>1){
    ctx.beginPath();
    var p0=toC(state.history[0].center.r,state.history[0].center.i);
    ctx.moveTo(p0[0],p0[1]);
    for(var i=1;i<total;i++){
      var pi=toC(state.history[i].center.r,state.history[i].center.i);
      ctx.lineTo(pi[0],pi[1]);
    }
    ctx.strokeStyle='rgba(235,219,178,0.15)'; ctx.lineWidth=1.5;
    ctx.setLineDash([3,4]); ctx.stroke(); ctx.setLineDash([]);
  }

  // Dots
  for(var idx=0;idx<total;idx++){
    var h=state.history[idx];
    var cp=toC(h.center.r,h.center.i);
    var isLast=idx===total-1;
    ctx.beginPath(); ctx.arc(cp[0],cp[1],isLast?6:4,0,2*Math.PI);
    ctx.fillStyle=stepColor(idx,total-1); ctx.fill();
    if(isLast){ctx.strokeStyle='rgba(235,219,178,0.6)';ctx.lineWidth=1.5;ctx.stroke();}
  }

  // Label
  if(total>0){
    var last=state.history[total-1];
    var lp=toC(last.center.r,last.center.i);
    ctx.fillStyle=stepColor(total-1,total-1); ctx.font='13px EB Garamond';
    ctx.fillText('z\u2080='+fmtC(last.center,2),lp[0]+10,lp[1]-10);
  }

  // Origin
  var op=toC(0,0);
  ctx.beginPath(); ctx.arc(op[0],op[1],4,0,2*Math.PI);
  ctx.fillStyle='#b16286'; ctx.fill();
  ctx.fillStyle='#b16286'; ctx.font='12px EB Garamond';
  ctx.fillText('0 (branch pt)',op[0]+7,op[1]-6);

  drawAxisLabels(ctx,WORLD,ox,oy);
}

// ── Draw √z-plane ─────────────────────────────────────────────────────────
function drawSqrtPlane(){
  ctx2.clearRect(0,0,CSIZE,CSIZE);
  drawGrid(ctx2,WORLD2);
  var axes=drawAxes(ctx2,WORLD2);
  var ox=axes[0],oy=axes[1];

  var total=state.history.length;

  // Shade right half-plane
  ctx2.fillStyle='rgba(131,165,152,0.04)';
  ctx2.fillRect(ox,0,CSIZE-ox,CSIZE);
  ctx2.strokeStyle='rgba(131,165,152,0.2)'; ctx2.lineWidth=1;
  ctx2.setLineDash([4,4]);
  ctx2.beginPath(); ctx2.moveTo(ox,0); ctx2.lineTo(ox,CSIZE); ctx2.stroke();
  ctx2.setLineDash([]);
  ctx2.fillStyle='rgba(131,165,152,0.5)'; ctx2.font='10px JetBrains Mono';
  ctx2.fillText('principal branch',ox+6,14);

  // Trail
  if(total>1){
    ctx2.beginPath();
    var p0=toC2(state.history[0].sqrt.r,state.history[0].sqrt.i);
    ctx2.moveTo(p0[0],p0[1]);
    for(var i=1;i<total;i++){
      var pi=toC2(state.history[i].sqrt.r,state.history[i].sqrt.i);
      ctx2.lineTo(pi[0],pi[1]);
    }
    ctx2.strokeStyle='rgba(235,219,178,0.15)'; ctx2.lineWidth=1.5;
    ctx2.setLineDash([3,4]); ctx2.stroke(); ctx2.setLineDash([]);
  }

  // Dots
  for(var idx=0;idx<total;idx++){
    var h=state.history[idx];
    var sp=toC2(h.sqrt.r,h.sqrt.i);
    var isLast=idx===total-1;
    ctx2.beginPath(); ctx2.arc(sp[0],sp[1],isLast?6:4,0,2*Math.PI);
    ctx2.fillStyle=stepColor(idx,total-1); ctx2.fill();
    if(isLast){ctx2.strokeStyle='rgba(235,219,178,0.6)';ctx2.lineWidth=1.5;ctx2.stroke();}
  }

  // Label
  if(total>0){
    var last=state.history[total-1];
    var sp=toC2(last.sqrt.r,last.sqrt.i);
    ctx2.fillStyle=stepColor(total-1,total-1); ctx2.font='13px EB Garamond';
    ctx2.fillText('\u221az\u2080='+fmtC(last.sqrt,2),sp[0]+10,sp[1]-10);
  }

  drawAxisLabels(ctx2,WORLD2,ox,oy);
}

function drawBoth(){drawZPlane();drawSqrtPlane();}

// ── Handle a tap/click at CSS pixel (cssX, cssY) on the z-plane canvas ───
function handleTap(cssX,cssY){
  var ic=cssToInternal(canvas,cssX,cssY);
  var wx=internalToWorld(ic[0],ic[1]);
  var clicked={r:wx[0],i:wx[1]};

  var R=radiusOfConvergence(state.center);
  var dist=cabs(csub(clicked,state.center));
  if(dist>=R){
    // Flash red dot and bail
    ctx.beginPath(); ctx.arc(ic[0],ic[1],14,0,2*Math.PI);
    ctx.fillStyle='rgba(251,73,52,0.3)'; ctx.fill();
    setTimeout(drawBoth,350);
    return;
  }

  var coeffs=seriesCoeffs(state.center,state.sqrtVal,6);
  var newSqrt=evalSeries(state.center,coeffs,clicked);

  state.history.push({center:{r:clicked.r,i:clicked.i},sqrt:{r:newSqrt.r,i:newSqrt.i}});
  state.center=clicked;
  state.sqrtVal=newSqrt;
  state.stepCount++;

  // Monodromy check
  var newR=radiusOfConvergence(state.center);
  var d1=cabs(csub({r:1,i:0},state.center));
  if(d1<newR&&state.stepCount>1){
    var c2=seriesCoeffs(state.center,state.sqrtVal,6);
    var v1=evalSeries(state.center,c2,{r:1,i:0});
    if(v1.r<0) document.getElementById('monodromy-alert').classList.add('show');
  }

  updateUI();
  drawBoth();
}

// Mouse clicks
canvas.addEventListener('click',function(e){
  handleTap(e.clientX,e.clientY);
});

// Touch taps (prevent default to stop scroll/zoom interference)
canvas.addEventListener('touchend',function(e){
  e.preventDefault();
  var t=e.changedTouches[0];
  handleTap(t.clientX,t.clientY);
},{passive:false});

// ── Init ──────────────────────────────────────────────────────────────────
state.history=[{center:{r:1,i:0},sqrt:{r:1,i:0}}];
updateUI();
drawBoth();
</script>

<!-- Möbius Strip Non-Orientability Widget — Gruvbox Theme -->
<div id="mobius-orient-widget" style="font-family: 'Georgia', serif; background: #282828; border: 2px solid #504945; border-radius: 6px; padding: 16px; display: inline-block; text-align: center; max-width: 420px;">
  <p style="color: #a89984; font-size: 13px; margin: 0 0 8px 0; letter-spacing: 0.05em; text-transform: uppercase;">Non-Orientability</p>
  <canvas id="mobius-orient-canvas" width="400" height="300" style="display:block; border-radius: 4px; background: #1d2021;"></canvas>
  <div style="margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 12px;">
    <button id="mobius-play-btn" style="background:#458588; color:#ebdbb2; border:none; border-radius:4px; padding:6px 18px; font-family:'Georgia',serif; font-size:13px; cursor:pointer; letter-spacing:0.05em;">▶ Play</button>
    <span id="mobius-orient-label" style="color:#665c54; font-size:12px; font-style:italic; min-width:200px; text-align:left;">Press play to animate</span>
  </div>
  <p style="color:#665c54; font-size:11px; margin:8px 0 0 0; font-style:italic;">After a full loop, the vector flips!</p>
</div>

<script>
(function () {
  const canvas  = document.getElementById('mobius-orient-canvas');
  const playBtn = document.getElementById('mobius-play-btn');
  const label   = document.getElementById('mobius-orient-label');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) return;
  const extUint = gl.getExtension('OES_element_index_uint');

  /* ── shaders ── */
  const VS_STRIP = `
    attribute vec3 aPos;
    attribute vec3 aNorm;
    attribute float aEdge;
    uniform mat4 uMVP;
    uniform mat3 uNM;
    varying vec3 vNorm;
    varying float vEdge;
    void main(){
      gl_Position = uMVP * vec4(aPos, 1.0);
      vNorm = normalize(uNM * aNorm);
      vEdge = aEdge;
    }`;
  const FS_STRIP = `
    precision mediump float;
    varying vec3 vNorm;
    varying float vEdge;
    void main(){
      vec3 L    = normalize(vec3(1.0, 1.5, 2.0));
      vec3 base = mix(vec3(0.843,0.600,0.129), vec3(0.800,0.141,0.114), vEdge);
      float lum = 0.30 + 0.70 * max(max(dot(vNorm,L), 0.0), max(dot(-vNorm,L), 0.0));
      gl_FragColor = vec4(base * lum, 0.45);
    }`;
  const VS_FLAT = `
    attribute vec3 aPos;
    uniform mat4 uMVP;
    void main(){ gl_Position = uMVP * vec4(aPos, 1.0); }`;
  const FS_FLAT = `
    precision mediump float;
    uniform vec3 uColor;
    void main(){ gl_FragColor = vec4(uColor, 1.0); }`;

  function mkShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
    return s;
  }
  function mkProg(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, mkShader(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, mkShader(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
  }
  const stripProg = mkProg(VS_STRIP, FS_STRIP);
  const flatProg  = mkProg(VS_FLAT,  FS_FLAT);

  /* ── Möbius parametric functions ── */
  const R = 1.0, W = 0.42;
  function mPt(u, v) {
    const cu=Math.cos(u), su=Math.sin(u), c2=Math.cos(u/2), s2=Math.sin(u/2);
    return [(R+W*v*c2)*cu, (R+W*v*c2)*su, W*v*s2];
  }
  function mNrm(u, v) {
    const cu=Math.cos(u), su=Math.sin(u), c2=Math.cos(u/2), s2=Math.sin(u/2);
    const dxdu=-(R+W*v*c2)*su+W*v*(-s2/2)*cu, dydu=(R+W*v*c2)*cu+W*v*(-s2/2)*su, dzdu=W*v*(c2/2);
    const dxdv=W*c2*cu, dydv=W*c2*su, dzdv=W*s2;
    let nx=dydu*dzdv-dzdu*dydv, ny=dzdu*dxdv-dxdu*dzdv, nz=dxdu*dydv-dydu*dxdv;
    const nl=Math.sqrt(nx*nx+ny*ny+nz*nz)||1;
    return [nx/nl, ny/nl, nz/nl];
  }

  /* ── Full strip geometry ── */
  const NU=200, NV=30;
  const posArr=[], nrmArr=[], edgArr=[], idxArr=[];
  for (let i=0; i<=NU; i++) {
    const u=(i/NU)*2*Math.PI;
    for (let j=0; j<=NV; j++) {
      const v=(j/NV)*2-1;
      posArr.push(...mPt(u,v));
      nrmArr.push(...mNrm(u,v));
      edgArr.push(Math.abs(v)>0.82 ? 1.0 : 0.0);
    }
  }
  for (let i=0; i<NU; i++) for (let j=0; j<NV; j++) {
    const a=i*(NV+1)+j, b=a+1, c=a+(NV+1), d=c+1;
    idxArr.push(a,b,c, b,d,c);
  }
  function mkStaticBuf(type, Ctor, data) {
    const b=gl.createBuffer(); gl.bindBuffer(type,b);
    gl.bufferData(type, new Ctor(data), gl.STATIC_DRAW); return b;
  }
  const posBuf  = mkStaticBuf(gl.ARRAY_BUFFER, Float32Array, posArr);
  const nrmBuf  = mkStaticBuf(gl.ARRAY_BUFFER, Float32Array, nrmArr);
  const edgBuf  = mkStaticBuf(gl.ARRAY_BUFFER, Float32Array, edgArr);
  const idxBuf  = mkStaticBuf(gl.ELEMENT_ARRAY_BUFFER, extUint?Uint32Array:Uint16Array, idxArr);
  const idxType = extUint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
  const dynBuf  = gl.createBuffer();

  /* ── The vector travels along v=0 (centre of strip), u goes 0→2π ── */
  const NRM_OFF   = 0.022;
  const PATH_SAMP = 360;

  // Pre-sample full path in model space (offset above surface)
  const pathPts = [];
  for (let i=0; i<=PATH_SAMP; i++) {
    const u = (i/PATH_SAMP)*2*Math.PI;
    const pt=mPt(u,0), nr=mNrm(u,0);
    // offset along -normal to match arrow direction
    pathPts.push([pt[0]-nr[0]*NRM_OFF, pt[1]-nr[1]*NRM_OFF, pt[2]-nr[2]*NRM_OFF]);
  }

  /* ── Pin step: every 20° ── */
  const PIN_STEP = Math.PI / 9; // 20 degrees

  /* ── Fixed arrowhead perpendicular — from initial normal at u=0 ── */
  const _n0 = mNrm(0, 0);
  const _n0neg = [-_n0[0], -_n0[1], -_n0[2]]; // we draw arrows along -normal
  const _ax=Math.abs(_n0neg[0]), _ay=Math.abs(_n0neg[1]), _az=Math.abs(_n0neg[2]);
  let _cx, _cy, _cz;
  if (_ax<=_ay && _ax<=_az)  { _cx=0; _cy=-_n0neg[2]; _cz=_n0neg[1]; }
  else if (_ay<=_az)          { _cx=-_n0neg[2]; _cy=0; _cz=_n0neg[0]; }
  else                        { _cx=-_n0neg[1]; _cy=_n0neg[0]; _cz=0; }
  const _cl = Math.sqrt(_cx*_cx+_cy*_cy+_cz*_cz)||1;
  const ARROW_PERP = [_cx/_cl, _cy/_cl, _cz/_cl];

  function buildArrow(base, dir, scale) {
    const tip = [base[0]+dir[0]*scale, base[1]+dir[1]*scale, base[2]+dir[2]*scale];
    const hs=scale*0.22, hw=hs*0.25;
    const cx=ARROW_PERP[0]*hw, cy=ARROW_PERP[1]*hw, cz=ARROW_PERP[2]*hw;
    const bk=[tip[0]-dir[0]*hs, tip[1]-dir[1]*hs, tip[2]-dir[2]*hs];
    return [
      base[0],base[1],base[2], tip[0],tip[1],tip[2],
      tip[0],tip[1],tip[2], bk[0]+cx,bk[1]+cy,bk[2]+cz,
      tip[0],tip[1],tip[2], bk[0]-cx,bk[1]-cy,bk[2]-cz,
    ];
  }

  /* ── Matrix math (column-major) ── */
  function mul4(a,b){
    const r=new Float32Array(16);
    for(let col=0;col<4;col++) for(let row=0;row<4;row++){
      let s=0; for(let k=0;k<4;k++) s+=a[k*4+row]*b[col*4+k]; r[col*4+row]=s;
    } return r;
  }
  function persp(fov,asp,n,f){
    const t=Math.tan(fov/2);
    return new Float32Array([1/(asp*t),0,0,0, 0,1/t,0,0, 0,0,-(f+n)/(f-n),-1, 0,0,-2*f*n/(f-n),0]);
  }
  function transl(tx,ty,tz){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1]);}
  function rotX(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1]);}
  function rotY(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,0,-s,0,0,1,0,0,s,0,c,0,0,0,0,1]);}
  function ul3(m){return new Float32Array([m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10]]);}

  /* ── Static model — strip never moves ── */
  const MODEL = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); // identity
  const NM_STATIC = ul3(MODEL);

  const PROJ = persp(Math.PI/4, canvas.width/canvas.height, 0.1, 20.0);

  /* ── lookAt helper (column-major) ── */
  function lookAt(eye, center, up) {
    const fx=center[0]-eye[0], fy=center[1]-eye[1], fz=center[2]-eye[2];
    const fl=Math.sqrt(fx*fx+fy*fy+fz*fz)||1;
    const f=[fx/fl,fy/fl,fz/fl];
    const ul=Math.sqrt(up[0]*up[0]+up[1]*up[1]+up[2]*up[2])||1;
    const u=[up[0]/ul,up[1]/ul,up[2]/ul];
    const rx=f[1]*u[2]-f[2]*u[1], ry=f[2]*u[0]-f[0]*u[2], rz=f[0]*u[1]-f[1]*u[0];
    const rl=Math.sqrt(rx*rx+ry*ry+rz*rz)||1;
    const r=[rx/rl,ry/rl,rz/rl];
    const uu=[r[1]*f[2]-r[2]*f[1], r[2]*f[0]-r[0]*f[2], r[0]*f[1]-r[1]*f[0]];
    // column-major: columns are r, uu, -f, then translation
    return new Float32Array([
      r[0],  uu[0], -f[0], 0,
      r[1],  uu[1], -f[1], 0,
      r[2],  uu[2], -f[2], 0,
      -(r[0]*eye[0]+r[1]*eye[1]+r[2]*eye[2]),
      -(uu[0]*eye[0]+uu[1]*eye[1]+uu[2]*eye[2]),
       (f[0]*eye[0]+f[1]*eye[1]+f[2]*eye[2]),
      1
    ]);
  }

  /* ── Draw helper ── */
  function uploadAndDraw(data, mode, count, color, lw) {
    gl.bindBuffer(gl.ARRAY_BUFFER, dynBuf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(fL.pos);
    gl.vertexAttribPointer(fL.pos, 3, gl.FLOAT, false, 0, 0);
    gl.uniform3f(fL.color, color[0], color[1], color[2]);
    if (lw) gl.lineWidth(lw);
    gl.drawArrays(mode, 0, count);
  }

  /* ── Uniform/attrib locations ── */
  const sL = {
    mvp:  gl.getUniformLocation(stripProg,'uMVP'),
    nm:   gl.getUniformLocation(stripProg,'uNM'),
    pos:  gl.getAttribLocation(stripProg,'aPos'),
    nrm:  gl.getAttribLocation(stripProg,'aNorm'),
    edge: gl.getAttribLocation(stripProg,'aEdge'),
  };
  const fL = {
    mvp:   gl.getUniformLocation(flatProg,'uMVP'),
    color: gl.getUniformLocation(flatProg,'uColor'),
    pos:   gl.getAttribLocation(flatProg,'aPos'),
  };

  /* ── Animation state ── */
  let playing=false, tParam=0, lastTS=0;
  const SPEED = 0.55; // radians/sec, full loop ~11s

  /* ── Drag rotation (active only when not playing) ──
     We orbit in spherical coords around the world origin so the camera
     position is continuous with the tracking camera's final position. ── */
  // Spherical coords: theta = azimuth (around Z), phi = elevation above XY
  let orbTheta = 0, orbPhi = 0, orbDist = 0;
  let dragging=false, dragLX=0, dragLY=0;
  let dragMode = false; // true once animation finishes and we switch to drag

  function eyeFromTracking(t) {
    const bPt = mPt(t, 0);
    const radX = Math.cos(t), radY = Math.sin(t);
    const D=1.5, H=1.2;
    return [bPt[0]+radX*D, bPt[1]+radY*D, bPt[2]+H];
  }

  function initOrbitFromEye(eye) {
    // Convert eye position to spherical coords around origin
    const x=eye[0], y=eye[1], z=eye[2];
    orbDist  = Math.sqrt(x*x+y*y+z*z);
    orbTheta = Math.atan2(y, x);
    orbPhi   = Math.asin(Math.max(-1, Math.min(1, z/orbDist)));
  }

  canvas.addEventListener('mousedown', e=>{
    if (playing) return;
    dragging=true; dragLX=e.clientX; dragLY=e.clientY;
  });
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    orbTheta -= (e.clientX-dragLX)*0.013; dragLX=e.clientX;
    orbPhi   += (e.clientY-dragLY)*0.013; dragLY=e.clientY;
    orbPhi    = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, orbPhi));
  });
  window.addEventListener('mouseup', ()=>dragging=false);
  canvas.addEventListener('touchstart', e=>{
    if (playing) return;
    dragging=true; dragLX=e.touches[0].clientX; dragLY=e.touches[0].clientY;
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchmove', e=>{
    if (!dragging) return;
    orbTheta -= (e.touches[0].clientX-dragLX)*0.013; dragLX=e.touches[0].clientX;
    orbPhi   += (e.touches[0].clientY-dragLY)*0.013; dragLY=e.touches[0].clientY;
    orbPhi    = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, orbPhi));
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchend', ()=>dragging=false);

  playBtn.addEventListener('click', () => {
    if (tParam >= 2*Math.PI) { tParam = 0; dragMode = false; } // restart
    playing = !playing;
    playBtn.textContent = playing ? '⏸ Pause' : '▶ Play';
    if (playing) lastTS = performance.now();
  });

  /* ── Render ── */
  function draw(ts) {
    const dt=Math.min((ts-lastTS)/1000, 0.05); lastTS=ts;
    if (playing) {
      tParam = Math.min(tParam + dt*SPEED, 2*Math.PI);
      if (tParam >= 2*Math.PI) {
        playing = false;
        playBtn.textContent = '▶ Play';
      }
    }

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.114, 0.125, 0.129, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    let VIEW, MVP, NM;
    const animDone = tParam >= 2*Math.PI - 0.001;

    if (!animDone) {
      // Tracking camera follows the basepoint
      const eye = eyeFromTracking(tParam);
      const bPt = mPt(tParam, 0);
      const radX = Math.cos(tParam), radY = Math.sin(tParam);
      const up = [-radX*0.3, -radY*0.3, 1.0];
      VIEW = lookAt(eye, [bPt[0],bPt[1],bPt[2]], up);
      MVP  = mul4(PROJ, mul4(VIEW, MODEL));
      NM   = NM_STATIC;
    } else {
      // On first entry to drag mode, seed the orbit from the tracking camera's final position
      if (!dragMode) {
        initOrbitFromEye(eyeFromTracking(2*Math.PI));
        dragMode = true;
      }
      // Spherical orbit around world origin
      const ex = orbDist * Math.cos(orbPhi) * Math.cos(orbTheta);
      const ey = orbDist * Math.cos(orbPhi) * Math.sin(orbTheta);
      const ez = orbDist * Math.sin(orbPhi);
      const up = [0, 0, 1];
      VIEW = lookAt([ex,ey,ez], [0,0,0], up);
      MVP  = mul4(PROJ, mul4(VIEW, MODEL));
      NM   = NM_STATIC;
    }

    /* ── Strip (semi-transparent) ── */
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false); // don't write depth for transparent surface
    gl.useProgram(stripProg);
    gl.uniformMatrix4fv(sL.mvp, false, MVP);
    gl.uniformMatrix3fv(sL.nm,  false, NM);
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.enableVertexAttribArray(sL.pos);
    gl.vertexAttribPointer(sL.pos, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf);
    gl.enableVertexAttribArray(sL.nrm);
    gl.vertexAttribPointer(sL.nrm, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, edgBuf);
    gl.enableVertexAttribArray(sL.edge);
    gl.vertexAttribPointer(sL.edge, 1, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
    gl.drawElements(gl.TRIANGLES, idxArr.length, idxType, 0);

    /* ── Overlays (opaque) ── */
    gl.depthMask(true);
    gl.useProgram(flatProg);
    gl.uniformMatrix4fv(fL.mvp, false, MVP);

    const tFrac   = tParam / (2*Math.PI); // 0..1

    /* Traversed path */
    if (tParam > 0.01) {
      const nT = Math.floor(tFrac * PATH_SAMP);
      if (nT > 1) {
        const verts=[];
        for (let i=0; i<nT; i++) verts.push(...pathPts[i], ...pathPts[i+1]);
        uploadAndDraw(verts, gl.LINES, nT*2, [0.40, 0.78, 0.55], 2.5);
      }
    }

    /* Pinned arrows every 20° */
    const numPins = Math.floor(tParam / PIN_STEP);
    for (let p=1; p<=numPins; p++) {
      const u = p * PIN_STEP;
      const pt=mPt(u,0), nr=mNrm(u,0);
      const dn = [-nr[0],-nr[1],-nr[2]];
      const base=[pt[0]+dn[0]*NRM_OFF, pt[1]+dn[1]*NRM_OFF, pt[2]+dn[2]*NRM_OFF];
      uploadAndDraw(buildArrow(base, dn, 0.18), gl.LINES, 6, [0.18, 0.32, 0.30], 1.5);
    }

    /* Current arrow */
    {
      const u = tParam;
      const pt=mPt(u,0), nr=mNrm(u,0);
      const dn = [-nr[0],-nr[1],-nr[2]];
      const base=[pt[0]+dn[0]*NRM_OFF, pt[1]+dn[1]*NRM_OFF, pt[2]+dn[2]*NRM_OFF];
      uploadAndDraw(buildArrow(base, dn, 0.22), gl.LINES, 6, [0.27, 0.50, 0.45], 2.5);

      /* Dot as cross */
      const [bx,by,bz] = base;
      const ds=0.018;
      uploadAndDraw([bx-ds,by,bz, bx+ds,by,bz, bx,by-ds,bz, bx,by+ds,bz],
                    gl.LINES, 4, [0.984,0.741,0.184], 2.5);
    }

    if (tParam >= 2*Math.PI) {
      label.style.color = '#b8bb26';
      label.textContent = `Full loop complete ↺ press play to replay`;
    } else if (playing || tParam > 0) {
      label.style.color = '#83a598';
      label.textContent = `${Math.round(tFrac*100)}% around the strip`;
    }

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>

</body>
</html>
